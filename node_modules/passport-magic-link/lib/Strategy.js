"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var PassportStrategy = require('passport-strategy');

var jwt = require('jsonwebtoken');

var _require = require('util'),
    promisify = _require.promisify;

var lookup = require('./lookup');

var memoryStorage = require('./MemoryStorage');

var MagicLinkStrategy = /*#__PURE__*/function (_PassportStrategy) {
  (0, _inherits2["default"])(MagicLinkStrategy, _PassportStrategy);

  var _super = _createSuper(MagicLinkStrategy);

  /**
   * @param {string} secret - The secret to sign the token
   * @param {Array} userFields - An array of mandatory user fields from the request
   * @param {Array} tokenField - The token field from the request
   * @param {Number} ttl - Time to live
   * @param {Boolean} passReqToCallbacks - Whether the req should be passed do the sendToken callback
   * @param {Boolean} verifyUserAfterToken - Whether the user should be verified after the token verification
   * @param {Function} sendToken - A function to deliver the token
   * @param {Function} verifyUser - A function to verify the user
   * @param {Object} storage - The storage for persistent tokens
   */
  function MagicLinkStrategy(_ref, sendToken, verifyUser) {
    var _this;

    var secret = _ref.secret,
        userFields = _ref.userFields,
        tokenField = _ref.tokenField,
        _ref$ttl = _ref.ttl,
        ttl = _ref$ttl === void 0 ? 60 * 10 : _ref$ttl,
        _ref$passReqToCallbac = _ref.passReqToCallbacks,
        passReqToCallbacks = _ref$passReqToCallbac === void 0 ? false : _ref$passReqToCallbac,
        _ref$verifyUserAfterT = _ref.verifyUserAfterToken,
        verifyUserAfterToken = _ref$verifyUserAfterT === void 0 ? false : _ref$verifyUserAfterT,
        _ref$storage = _ref.storage,
        storage = _ref$storage === void 0 ? memoryStorage : _ref$storage;
    (0, _classCallCheck2["default"])(this, MagicLinkStrategy);
    if (!secret) throw new Error('Magic Link authentication strategy requires an encryption secret');
    if (!userFields || !userFields.length) throw new Error('Magic Link authentication strategy requires an array of mandatory user fields');
    if (!tokenField) throw new Error('Magic Link authentication strategy requires a token field');
    if (!sendToken) throw new Error('Magic Link authentication strategy requires a sendToken function');
    if (!verifyUser) throw new Error('Magic Link authentication strategy requires a verifyUser function');
    _this = _super.call(this);
    _this.name = 'magiclink';
    _this.secret = secret;
    _this.ttl = ttl;
    _this.passReqToCallbacks = passReqToCallbacks;
    _this.verifyUserAfterToken = verifyUserAfterToken;
    _this.userFields = userFields;
    _this.tokenField = tokenField;
    _this.storage = storage;
    _this.sendToken = sendToken;
    _this.verifyUser = verifyUser;
    return _this;
  }

  (0, _createClass2["default"])(MagicLinkStrategy, [{
    key: "authenticate",
    value: function () {
      var _authenticate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(req) {
        var options,
            sanitizedOptions,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                sanitizedOptions = _objectSpread({
                  action: 'acceptToken'
                }, options); // Request token logic
                // ====================================

                if (!(sanitizedOptions.action === 'requestToken')) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", this.requestToken(req, sanitizedOptions));

              case 4:
                if (!(sanitizedOptions.action === 'acceptToken')) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", this.acceptToken(req, sanitizedOptions));

              case 6:
                return _context.abrupt("return", this.error(new Error('Unknown action')));

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function authenticate(_x) {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
  }, {
    key: "requestToken",
    value: function () {
      var _requestToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(req, options) {
        var userFields, user, i, fieldValue, createToken, token;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                userFields = {};
                i = 0;

              case 2:
                if (!(i < this.userFields.length)) {
                  _context2.next = 11;
                  break;
                }

                fieldValue = lookup(req.body, this.userFields[i]) || lookup(req.query, this.userFields[i]);

                if (!(typeof fieldValue === 'undefined')) {
                  _context2.next = 7;
                  break;
                }

                userFields = null;
                return _context2.abrupt("break", 11);

              case 7:
                userFields[this.userFields[i]] = fieldValue;

              case 8:
                i++;
                _context2.next = 2;
                break;

              case 11:
                if (userFields) {
                  _context2.next = 13;
                  break;
                }

                return _context2.abrupt("return", this.fail(new Error('Mandatory user fields missing')));

              case 13:
                if (this.verifyUserAfterToken) {
                  _context2.next = 33;
                  break;
                }

                _context2.prev = 14;

                if (!this.passReqToCallbacks) {
                  _context2.next = 21;
                  break;
                }

                _context2.next = 18;
                return this.verifyUser(req, userFields);

              case 18:
                user = _context2.sent;
                _context2.next = 24;
                break;

              case 21:
                _context2.next = 23;
                return this.verifyUser(userFields);

              case 23:
                user = _context2.sent;

              case 24:
                _context2.next = 29;
                break;

              case 26:
                _context2.prev = 26;
                _context2.t0 = _context2["catch"](14);
                return _context2.abrupt("return", this.error(_context2.t0));

              case 29:
                if (user) {
                  _context2.next = 31;
                  break;
                }

                return _context2.abrupt("return", this.fail({
                  message: options.authMessage || "No user found"
                }, 400));

              case 31:
                _context2.next = 34;
                break;

              case 33:
                user = userFields;

              case 34:
                // Generate JWT
                createToken = promisify(jwt.sign);
                _context2.prev = 35;
                _context2.next = 38;
                return createToken({
                  user: user,
                  iat: Math.floor(Date.now() / 1000)
                }, this.secret, {
                  expiresIn: this.ttl
                });

              case 38:
                token = _context2.sent;
                _context2.next = 44;
                break;

              case 41:
                _context2.prev = 41;
                _context2.t1 = _context2["catch"](35);
                return _context2.abrupt("return", this.error(_context2.t1));

              case 44:
                _context2.prev = 44;

                if (!this.passReqToCallbacks) {
                  _context2.next = 50;
                  break;
                }

                _context2.next = 48;
                return this.sendToken(req, user, token);

              case 48:
                _context2.next = 52;
                break;

              case 50:
                _context2.next = 52;
                return this.sendToken(user, token);

              case 52:
                _context2.next = 57;
                break;

              case 54:
                _context2.prev = 54;
                _context2.t2 = _context2["catch"](44);
                return _context2.abrupt("return", this.error(_context2.t2));

              case 57:
                return _context2.abrupt("return", this.pass({
                  message: 'Token succesfully delivered'
                }));

              case 58:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[14, 26], [35, 41], [44, 54]]);
      }));

      function requestToken(_x2, _x3) {
        return _requestToken.apply(this, arguments);
      }

      return requestToken;
    }()
  }, {
    key: "acceptToken",
    value: function () {
      var _acceptToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(req, options) {
        var token, user, tokenExpiration, verifyToken, _yield$verifyToken, tokenUser, exp, allowReuse, primaryKey, userUID, usedTokens;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                token = lookup(req.body, this.tokenField) || lookup(req.query, this.tokenField);

                if (token) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", this.fail({
                  message: 'Token missing'
                }));

              case 3:
                _context3.prev = 3;
                // Verify token
                verifyToken = promisify(jwt.verify);
                _context3.next = 7;
                return verifyToken(token, this.secret);

              case 7:
                _yield$verifyToken = _context3.sent;
                tokenUser = _yield$verifyToken.user;
                exp = _yield$verifyToken.exp;
                user = tokenUser;
                tokenExpiration = exp;
                _context3.next = 17;
                break;

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](3);
                return _context3.abrupt("return", this.fail({
                  message: _context3.t0.message
                }));

              case 17:
                if (!this.verifyUserAfterToken) {
                  _context3.next = 35;
                  break;
                }

                _context3.prev = 18;

                if (!this.passReqToCallbacks) {
                  _context3.next = 25;
                  break;
                }

                _context3.next = 22;
                return this.verifyUser(req, user);

              case 22:
                user = _context3.sent;
                _context3.next = 28;
                break;

              case 25:
                _context3.next = 27;
                return this.verifyUser(user);

              case 27:
                user = _context3.sent;

              case 28:
                _context3.next = 33;
                break;

              case 30:
                _context3.prev = 30;
                _context3.t1 = _context3["catch"](18);
                return _context3.abrupt("return", this.error(_context3.t1));

              case 33:
                if (user) {
                  _context3.next = 35;
                  break;
                }

                return _context3.abrupt("return", this.fail({
                  message: options.authMessage || "No user found"
                }, 400));

              case 35:
                // Invalidate already used tokens
                allowReuse = options.allowReuse || false;
                primaryKey = options.userPrimaryKey || 'email';

                if (allowReuse) {
                  _context3.next = 51;
                  break;
                }

                // Get used tokens from storage
                userUID = user[primaryKey];
                _context3.next = 41;
                return this.storage.get(userUID);

              case 41:
                _context3.t2 = _context3.sent;

                if (_context3.t2) {
                  _context3.next = 44;
                  break;
                }

                _context3.t2 = {};

              case 44:
                usedTokens = _context3.t2;

                if (!usedTokens[token]) {
                  _context3.next = 47;
                  break;
                }

                return _context3.abrupt("return", this.fail({
                  message: options.tokenAlreadyUsedMessage || 'Token was already used',
                  status: 400
                }));

              case 47:
                // If you using a persistent token storage you might want to
                // regularly prune expired tokens
                Object.keys(usedTokens).forEach(function (token) {
                  var expiration = usedTokens[token];

                  if (expiration <= Date.now()) {
                    delete usedTokens[token];
                  }
                }); // Revoke the token (No need to revoke already expired tokens)

                usedTokens[token] = tokenExpiration;
                _context3.next = 51;
                return this.storage.set(userUID, usedTokens);

              case 51:
                return _context3.abrupt("return", this.success(user));

              case 52:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[3, 14], [18, 30]]);
      }));

      function acceptToken(_x4, _x5) {
        return _acceptToken.apply(this, arguments);
      }

      return acceptToken;
    }()
  }]);
  return MagicLinkStrategy;
}(PassportStrategy);

module.exports = MagicLinkStrategy;